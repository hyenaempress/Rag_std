Django를 사용해서 RAG(Retrieval-Augmented Generation) 챗봇을 만든 전체 과정을 단계별로 정리한 문서입니다.

## 🎯 프로젝트 개요

- **목표**: 문서 업로드 후 질문-답변이 가능한 RAG 시스템
- **기술 스택**: Django, LangChain, 키워드 기반 검색
- **주요 기능**: 텍스트/파일 업로드, 실시간 채팅, 문서 검색

## 📁 1단계: 프로젝트 초기 설정

```bash
# 현재 위치로 이동
PS D:\work\Rag_std\django_rag> cd ..
PS D:\work\Rag_std> mkdir django_rag_chatbot
PS D:\work\Rag_std> cd django_rag_chatbot

# Django 프로젝트 생성 (현재 폴더에)
PS D:\work\Rag_std\django_rag_chatbot> django-admin startproject mainapp .

# Django 앱 생성
PS D:\work\Rag_std\django_rag_chatbot> python manage.py startapp chatbot

# 템플릿 디렉토리 생성
PS D:\work\Rag_std\django_rag_chatbot> mkdir templates
PS D:\work\Rag_std\django_rag_chatbot> mkdir templates\chatbot
```

이렇게 하면 깔끔한 구조가 될 거예요:

```
django_rag_chatbot/
├── manage.py
├── mainapp/
│   ├── settings.py
│   ├── urls.py
│   └── ...
├── chatbot/
│   ├── views.py
│   ├── models.py
│   └── ...
└── templates/
    └── chatbot/
```

그리고 서버 실행해서 잘 되는지 확인해보세요:

bash

```bash
PS D:\work\Rag_std\django_rag_chatbot> python manage.py runserver
```

## 1단계: settings.py 설정

`mainapp/settings.py`를 열어서 수정:

python

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'chatbot',  # 추가
]

# 템플릿 경로 추가
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],  # 이 부분 수정
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

## 2단계: URL 연결

`mainapp/urls.py`:

python

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('chatbot.urls')),  # 추가
]
```

## 3단계: chatbot 앱의 urls.py 생성

`chatbot/urls.py` 파일을 새로 만들어서:

python

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.chatbot_view, name='chatbot'),
]
```

## 4단계: 간단한 뷰 만들기

`chatbot/views.py`:

python

```python
from django.shortcuts import render

def chatbot_view(request):
    return render(request, 'chatbot/chatbot.html')
```

## 5단계: 기본 템플릿 만들기

`templates/chatbot/chatbot.html`:

html

```html
<!DOCTYPE html>
<html>
<head>
    <title>RAG 챗봇</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>RAG 챗봇 테스트</h1>
    <p>설정이 제대로 되었습니다!</p>
</body>
</html>
```

이제 서버 실행해서 `http://127.0.0.1:8000/`에서 확인해보세요!

bash

```bash
python manage.py runserver
```

페이지가 나오면 다음 단계로 넘어갈 수 있어요.

## 6단계: 채팅 UI 만들기

`templates/chatbot/chatbot.html`을 다시 만들어요:

html

```html
<!DOCTYPE html>
<html>
<head>
    <title>RAG 챗봇</title>
    <meta charset="utf-8">
    <style>
        .chat-container { 
            max-width: 800px; 
            margin: 50px auto; 
            border: 1px solid #ddd; 
            border-radius: 10px;
            overflow: hidden;
        }
        .chat-header { 
            background: #007bff; 
            color: white; 
            padding: 15px; 
            text-align: center; 
        }
        .chat-box { 
            height: 400px; 
            overflow-y: auto; 
            padding: 20px; 
            background: #f9f9f9; 
        }
        .message { 
            margin-bottom: 15px; 
            padding: 10px; 
            border-radius: 10px; 
            max-width: 70%; 
        }
        .user-message { 
            background: #007bff; 
            color: white; 
            margin-left: auto; 
            text-align: right; 
        }
        .bot-message { 
            background: white; 
            border: 1px solid #ddd; 
        }
        .input-container { 
            padding: 20px; 
            background: white; 
            display: flex; 
            gap: 10px; 
        }
        #messageInput { 
            flex: 1; 
            padding: 10px; 
            border: 1px solid #ddd; 
            border-radius: 5px; 
        }
        #sendBtn { 
            padding: 10px 20px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        #sendBtn:hover { 
            background: #0056b3; 
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h2>RAG 챗봇</h2>
        </div>
        
        <div id="chatBox" class="chat-box">
            <div class="message bot-message">
                안녕하세요! 무엇을 도와드릴까요?
            </div>
        </div>
        
        <div class="input-container">
            <input type="text" id="messageInput" placeholder="메시지를 입력하세요..." onkeypress="handleKeyPress(event)">
            <button id="sendBtn" onclick="sendMessage()">전송</button>
        </div>
    </div>

    <script>
        function addMessage(message, isUser) {
            const chatBox = document.getElementById('chatBox');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + (isUser ? 'user-message' : 'bot-message');
            messageDiv.textContent = message;
            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (!message) return;

            // 사용자 메시지 표시
            addMessage(message, true);
            input.value = '';

            // 임시로 echo 응답 (나중에 API 연결)
            setTimeout(() => {
                addMessage(`Echo: ${message}`, false);
            }, 500);
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }
    </script>
</body>
</html>
```

이제 페이지를 새로고침하면 실제 채팅처럼 보이는 인터페이스

## 7단계: AJAX API 만들기

### `chatbot/views.py` 수정:

python

```python
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json

def chatbot_view(request):
    return render(request, 'chatbot/chatbot.html')

@csrf_exempt  # 개발용 - 나중에 CSRF 토큰 사용하는게 좋음
def chat_api(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            user_message = data.get('message', '')
            
            # 간단한 키워드 응답 로직
            bot_response = get_bot_response(user_message)
            
            return JsonResponse({
                'response': bot_response,
                'status': 'success'
            })
        except Exception as e:
            return JsonResponse({
                'response': '오류가 발생했습니다.',
                'status': 'error'
            })
    
    return JsonResponse({'status': 'error', 'message': 'POST 요청만 허용됩니다.'})

def get_bot_response(message):
    """간단한 키워드 기반 응답"""
    message = message.lower()
    
    if '안녕' in message or 'hello' in message:
        return "안녕하세요! 무엇을 도와드릴까요?"
    elif '이름' in message:
        return "저는 RAG 챗봇입니다!"
    elif '날씨' in message:
        return "죄송합니다. 아직 날씨 정보는 제공하지 않습니다."
    elif '시간' in message:
        from datetime import datetime
        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        return f"현재 시간은 {now}입니다."
    elif 'rag' in message:
        return "RAG는 Retrieval-Augmented Generation의 줄임말로, 문서 검색 기반 생성 AI입니다!"
    elif '도움' in message or 'help' in message:
        return "저는 문서 기반 질문에 답변할 수 있습니다. 궁금한 것을 물어보세요!"
    else:
        return f"'{message}'에 대해 더 구체적으로 알려주시면 도움을 드릴 수 있어요!"
```

### `chatbot/urls.py` 수정:

python

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.chatbot_view, name='chatbot'),
    path('api/chat/', views.chat_api, name='chat_api'),  # API 엔드포인트 추가
]
```

### HTML의 JavaScript 부분 수정:

`templates/chatbot/chatbot.html`의 `<script>` 부분을 이렇게 바꿔주세요:

javascript

```javascript
<script>
    function addMessage(message, isUser) {
        const chatBox = document.getElementById('chatBox');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ' + (isUser ? 'user-message' : 'bot-message');
        messageDiv.textContent = message;
        chatBox.appendChild(messageDiv);
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    async function sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        if (!message) return;

        // 사용자 메시지 표시
        addMessage(message, true);
        input.value = '';

        // 로딩 메시지
        addMessage('생각 중...', false);

        try {
            // Django API 호출
            const response = await fetch('/api/chat/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({message: message})
            });
            
            const data = await response.json();
            
            // 로딩 메시지 제거
            const chatBox = document.getElementById('chatBox');
            chatBox.removeChild(chatBox.lastChild);
            
            // 실제 응답 표시
            addMessage(data.response, false);
            
        } catch (error) {
            console.error('Error:', error);
            // 로딩 메시지 제거
            const chatBox = document.getElementById('chatBox');
            chatBox.removeChild(chatBox.lastChild);
            addMessage('죄송합니다. 오류가 발생했습니다.', false);
        }
    }

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }
</script>
```

이제 서버를 다시 실행하고 테스트해보세요:

bash

```bash
python manage.py runserver
```

- "안녕하세요" 입력해보기
- "시간" 입력해보기
- "RAG" 입력해보기

실제로 Django 서버와 통신하면서 키워드 기반으로 응답
## 8단계: RAG 기능 추가

### 1. 먼저 필요한 라이브러리 설치

bash

```bash
pip install chromadb langchain sentence-transformers pypdf2 python-docx
```

### 2. RAG 엔진 만들기

`chatbot/rag_engine.py` 파일을 새로 만들어요:

python

```python
import os
import chromadb
from langchain.vectorstores import Chroma
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.document_loaders import PyPDFLoader, TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.docstore.document import Document
import docx

class RAGEngine:
    def __init__(self):
        self.embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2"
        )
        self.vectorstore = None
        self.vectorstore_path = "./vectorstore"
        self.load_existing_vectorstore()
    
    def load_existing_vectorstore(self):
        """기존 벡터스토어가 있으면 로드"""
        if os.path.exists(self.vectorstore_path):
            try:
                self.vectorstore = Chroma(
                    persist_directory=self.vectorstore_path,
                    embedding_function=self.embeddings
                )
                print("기존 벡터스토어를 로드했습니다.")
            except:
                print("벡터스토어 로드 실패. 새로 생성합니다.")
                self.vectorstore = None
    
    def add_text_document(self, text, title="문서"):
        """텍스트를 직접 벡터스토어에 추가"""
        # 텍스트를 청크로 나누기
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            separators=["\n\n", "\n", ". ", " "]
        )
        
        # Document 객체 생성
        doc = Document(page_content=text, metadata={"source": title})
        chunks = text_splitter.split_documents([doc])
        
        # 벡터스토어에 추가
        if self.vectorstore is None:
            self.vectorstore = Chroma.from_documents(
                chunks,
                embedding=self.embeddings,
                persist_directory=self.vectorstore_path
            )
        else:
            self.vectorstore.add_documents(chunks)
        
        self.vectorstore.persist()
        return len(chunks)
    
    def add_file_document(self, file_path):
        """파일을 벡터스토어에 추가"""
        try:
            # 파일 확장자에 따라 로더 선택
            if file_path.endswith('.pdf'):
                loader = PyPDFLoader(file_path)
                documents = loader.load()
            elif file_path.endswith('.txt'):
                loader = TextLoader(file_path, encoding='utf-8')
                documents = loader.load()
            elif file_path.endswith('.docx'):
                # docx 파일 처리
                doc = docx.Document(file_path)
                text = '\n'.join([paragraph.text for paragraph in doc.paragraphs])
                documents = [Document(page_content=text, metadata={"source": file_path})]
            else:
                return False, "지원하지 않는 파일 형식입니다."
            
            # 텍스트 분할
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=1000,
                chunk_overlap=200
            )
            chunks = text_splitter.split_documents(documents)
            
            # 벡터스토어에 추가
            if self.vectorstore is None:
                self.vectorstore = Chroma.from_documents(
                    chunks,
                    embedding=self.embeddings,
                    persist_directory=self.vectorstore_path
                )
            else:
                self.vectorstore.add_documents(chunks)
            
            self.vectorstore.persist()
            return True, f"{len(chunks)}개 청크가 추가되었습니다."
            
        except Exception as e:
            return False, f"파일 처리 중 오류: {str(e)}"
    
    def search_documents(self, query, k=3):
        """문서에서 관련 내용 검색"""
        if self.vectorstore is None:
            return []
        
        try:
            docs = self.vectorstore.similarity_search(query, k=k)
            return docs
        except:
            return []
    
    def get_rag_response(self, query):
        """RAG 기반 응답 생성"""
        # 관련 문서 검색
        relevant_docs = self.search_documents(query, k=3)
        
        if not relevant_docs:
            return "죄송합니다. 관련된 문서를 찾을 수 없습니다. 먼저 문서를 업로드해주세요."
        
        # 검색된 문서들을 컨텍스트로 조합
        context = "\n\n".join([doc.page_content for doc in relevant_docs])
        
        # 간단한 응답 생성 (실제로는 LLM API를 사용하는게 좋음)
        response = f"검색된 관련 내용:\n\n{context[:800]}..."  # 800자로 제한
        
        return response
    
    def get_document_count(self):
        """저장된 문서 개수 확인"""
        if self.vectorstore is None:
            return 0
        try:
            collection = self.vectorstore._collection
            return collection.count()
        except:
            return 0

# 전역 RAG 엔진 인스턴스
rag_engine = RAGEngine()
```

### 3. 모델 추가

`chatbot/models.py`:

python

```python
from django.db import models

class Document(models.Model):
    title = models.CharField(max_length=200)
    file = models.FileField(upload_to='documents/', null=True, blank=True)
    text_content = models.TextField(null=True, blank=True)  # 직접 입력한 텍스트
    uploaded_at = models.DateTimeField(auto_now_add=True)
    processed = models.BooleanField(default=False)
    chunk_count = models.IntegerField(default=0)
    
    def __str__(self):
        return self.title
```

### 4. 뷰 업데이트

`chatbot/views.py`:

python

```python
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.storage import default_storage
import json
import os
from .rag_engine import rag_engine
from .models import Document

def chatbot_view(request):
    # 저장된 문서 개수 정보
    doc_count = rag_engine.get_document_count()
    context = {
        'document_count': doc_count
    }
    return render(request, 'chatbot/chatbot.html', context)

@csrf_exempt
def chat_api(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            user_message = data.get('message', '')
            
            # RAG 응답 시도
            if rag_engine.get_document_count() > 0:
                bot_response = rag_engine.get_rag_response(user_message)
            else:
                bot_response = get_simple_response(user_message)
            
            return JsonResponse({
                'response': bot_response,
                'status': 'success'
            })
        except Exception as e:
            return JsonResponse({
                'response': f'오류가 발생했습니다: {str(e)}',
                'status': 'error'
            })
    
    return JsonResponse({'status': 'error', 'message': 'POST 요청만 허용됩니다.'})

@csrf_exempt
def upload_text_api(request):
    """텍스트 직접 업로드"""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            text = data.get('text', '')
            title = data.get('title', '직접 입력 문서')
            
            if not text.strip():
                return JsonResponse({'status': 'error', 'message': '텍스트를 입력해주세요.'})
            
            # 데이터베이스에 저장
            doc = Document.objects.create(
                title=title,
                text_content=text,
                processed=False
            )
            
            # RAG 엔진에 추가
            chunk_count = rag_engine.add_text_document(text, title)
            
            # 처리 완료 표시
            doc.processed = True
            doc.chunk_count = chunk_count
            doc.save()
            
            return JsonResponse({
                'status': 'success', 
                'message': f'텍스트가 업로드되었습니다. ({chunk_count}개 청크 생성)',
                'document_count': rag_engine.get_document_count()
            })
            
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})

@csrf_exempt
def upload_file_api(request):
    """파일 업로드"""
    if request.method == 'POST' and request.FILES.get('file'):
        try:
            file = request.FILES['file']
            
            # 파일 저장
            file_path = default_storage.save(f'documents/{file.name}', file)
            full_path = default_storage.path(file_path)
            
            # 데이터베이스에 저장
            doc = Document.objects.create(
                title=file.name,
                file=file_path,
                processed=False
            )
            
            # RAG 엔진에 추가
            success, message = rag_engine.add_file_document(full_path)
            
            if success:
                doc.processed = True
                doc.save()
                return JsonResponse({
                    'status': 'success', 
                    'message': f'파일이 업로드되었습니다. {message}',
                    'document_count': rag_engine.get_document_count()
                })
            else:
                doc.delete()  # 실패시 DB에서 제거
                return JsonResponse({'status': 'error', 'message': message})
                
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})

def get_simple_response(message):
    """문서가 없을 때의 간단한 응답"""
    message = message.lower()
    
    if '안녕' in message:
        return "안녕하세요! 문서를 업로드하면 더 정확한 답변을 드릴 수 있어요."
    elif '문서' in message or '업로드' in message:
        return "아래 업로드 섹션에서 텍스트나 파일을 업로드해주세요!"
    else:
        return "아직 업로드된 문서가 없습니다. 먼저 문서를 업로드한 후 질문해주세요."
```

### 5. URL 업데이트

`chatbot/urls.py`:

python

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.chatbot_view, name='chatbot'),
    path('api/chat/', views.chat_api, name='chat_api'),
    path('api/upload-text/', views.upload_text_api, name='upload_text'),
    path('api/upload-file/', views.upload_file_api, name='upload_file'),
]
```

### 6. 설정에 미디어 파일 경로 추가

`mainapp/settings.py`:

python

```python
import os

# 기존 설정들...

# 미디어 파일 설정 추가
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
```

`mainapp/urls.py`:

python

```python
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('chatbot.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

### 7. 데이터베이스 마이그레이션

bash

```bash
python manage.py makemigrations
python manage.py migrate
```

이제 기본 RAG 구조가 만들어졌어요!


디버깅 후 수정 

```
import os

from langchain_community.vectorstores import Chroma

from langchain_community.document_loaders import PyPDFLoader, TextLoader

from langchain_text_splitters import RecursiveCharacterTextSplitter

from langchain_core.documents import Document

import docx

  

class SimpleEmbeddings:

    """간단한 TF-IDF 기반 임베딩 (PyTorch 없이)"""

    def __init__(self):

        from sklearn.feature_extraction.text import TfidfVectorizer

        self.vectorizer = TfidfVectorizer(max_features=1000)

        self.fitted = False

    def embed_documents(self, texts):

        if not self.fitted:

            self.vectorizer.fit(texts)

            self.fitted = True

        return self.vectorizer.transform(texts).toarray().tolist()

    def embed_query(self, text):

        if not self.fitted:

            return [0] * 1000

        return self.vectorizer.transform([text]).toarray()[0].tolist()

  

class RAGEngine:

    def __init__(self):

        # 일단 간단한 임베딩 사용

        try:

            from langchain_community.embeddings import HuggingFaceEmbeddings

            self.embeddings = HuggingFaceEmbeddings(

                model_name="sentence-transformers/all-MiniLM-L6-v2"

            )

            print("HuggingFace 임베딩을 사용합니다.")

        except Exception as e:

            print(f"HuggingFace 임베딩 로드 실패: {e}")

            print("간단한 TF-IDF 임베딩을 사용합니다.")

            self.embeddings = SimpleEmbeddings()

        self.vectorstore = None

        self.vectorstore_path = "./vectorstore"

        self.documents = []  # 문서 저장용

        # 일단 벡터스토어 로딩은 스킵

    def add_text_document(self, text, title="문서"):

        """텍스트를 저장 (일단 간단하게)"""

        # 텍스트를 청크로 나누기

        text_splitter = RecursiveCharacterTextSplitter(

            chunk_size=1000,

            chunk_overlap=200,

            separators=["\n\n", "\n", ". ", " "]

        )

        doc = Document(page_content=text, metadata={"source": title})

        chunks = text_splitter.split_documents([doc])

        # 일단 메모리에만 저장

        self.documents.extend(chunks)

        return len(chunks)

    def add_file_document(self, file_path):

        """파일을 문서로 추가"""

        try:

            if file_path.endswith('.pdf'):

                loader = PyPDFLoader(file_path)

                documents = loader.load()

            elif file_path.endswith('.txt'):

                loader = TextLoader(file_path, encoding='utf-8')

                documents = loader.load()

            elif file_path.endswith('.docx'):

                doc = docx.Document(file_path)

                text = '\n'.join([paragraph.text for paragraph in doc.paragraphs])

                documents = [Document(page_content=text, metadata={"source": file_path})]

            else:

                return False, "지원하지 않는 파일 형식입니다."

            text_splitter = RecursiveCharacterTextSplitter(

                chunk_size=1000,

                chunk_overlap=200

            )

            chunks = text_splitter.split_documents(documents)

            # 메모리에 저장

            self.documents.extend(chunks)

            return True, f"{len(chunks)}개 청크가 추가되었습니다."

        except Exception as e:

            return False, f"파일 처리 중 오류: {str(e)}"

    def search_documents(self, query, k=3):

        """간단한 키워드 기반 검색"""

        if not self.documents:

            return []

        query = query.lower()

        scored_docs = []

        for doc in self.documents:

            content = doc.page_content.lower()

            score = 0

            # 간단한 키워드 매칭

            for word in query.split():

                if word in content:

                    score += content.count(word)

            if score > 0:

                scored_docs.append((doc, score))

        # 점수순 정렬

        scored_docs.sort(key=lambda x: x[1], reverse=True)

        return [doc for doc, score in scored_docs[:k]]

    def get_rag_response(self, query):

        """RAG 기반 응답 생성"""

        relevant_docs = self.search_documents(query, k=3)

        if not relevant_docs:

            return "죄송합니다. 관련된 문서를 찾을 수 없습니다. 먼저 문서를 업로드해주세요."

        context = "\n\n".join([doc.page_content for doc in relevant_docs])

        response = f"검색된 관련 내용:\n\n{context[:800]}..."

        return response

    def get_document_count(self):

        """저장된 문서 청크 개수"""

        return len(self.documents)

```
  
## 9단계: HTML 업데이트 - 문서 업로드 기능 추가

`templates/chatbot/chatbot.html`을 완전히 새로 만들어요:

html

```html
<!DOCTYPE html>
<html>
<head>
    <title>RAG 챗봇</title>
    <meta charset="utf-8">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .main-content {
            display: flex;
            gap: 20px;
        }
        .upload-section {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        .chat-section {
            flex: 2;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .upload-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        .upload-tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            padding: 10px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
        }
        .tab-btn.active {
            background: #667eea;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .form-group textarea {
            height: 120px;
            resize: vertical;
        }
        .upload-btn {
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
        }
        .upload-btn:hover {
            background: #218838;
        }
        .status-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .chat-header {
            background: #667eea;
            color: white;
            padding: 15px 20px;
            text-align: center;
        }
        .chat-box {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: #f9f9f9;
        }
        .message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .user-message {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        .bot-message {
            background: white;
            border: 1px solid #ddd;
            white-space: pre-line;
        }
        .input-container {
            padding: 20px;
            background: white;
            display: flex;
            gap: 10px;
            border-top: 1px solid #eee;
        }
        #messageInput {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
        }
        #sendBtn {
            padding: 12px 25px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
        }
        #sendBtn:hover {
            background: #5a67d8;
        }
        .loading {
            opacity: 0.7;
        }
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 RAG 챗봇</h1>
            <p>문서를 업로드하고 질문해보세요!</p>
        </div>

        <div class="main-content">
            <!-- 업로드 섹션 -->
            <div class="upload-section">
                <div class="upload-header">📁 문서 업로드</div>
                
                <div class="upload-tabs">
                    <button class="tab-btn active" onclick="showTab('text-tab')">텍스트 입력</button>
                    <button class="tab-btn" onclick="showTab('file-tab')">파일 업로드</button>
                </div>

                <!-- 텍스트 입력 탭 -->
                <div id="text-tab" class="tab-content active">
                    <div class="form-group">
                        <label>문서 제목:</label>
                        <input type="text" id="textTitle" placeholder="문서 제목을 입력하세요">
                    </div>
                    <div class="form-group">
                        <label>내용:</label>
                        <textarea id="textContent" placeholder="문서 내용을 입력하세요..."></textarea>
                    </div>
                    <button class="upload-btn" onclick="uploadText()">텍스트 업로드</button>
                </div>

                <!-- 파일 업로드 탭 -->
                <div id="file-tab" class="tab-content">
                    <div class="form-group">
                        <label>파일 선택:</label>
                        <input type="file" id="fileInput" accept=".txt,.pdf,.docx">
                    </div>
                    <button class="upload-btn" onclick="uploadFile()">파일 업로드</button>
                </div>

                <!-- 상태 정보 -->
                <div class="status-info">
                    <strong>📊 현재 상태:</strong><br>
                    저장된 문서: <span id="docCount">{{ document_count }}</span>개<br>
                    <div id="uploadMessage"></div>
                </div>
            </div>

            <!-- 채팅 섹션 -->
            <div class="chat-section">
                <div class="chat-header">
                    <h3>💬 채팅</h3>
                </div>
                
                <div id="chatBox" class="chat-box">
                    <div class="message bot-message">
                        안녕하세요! 문서를 업로드한 후 질문해주세요. 📚
                    </div>
                </div>
                
                <div class="input-container">
                    <input type="text" id="messageInput" placeholder="질문을 입력하세요..." onkeypress="handleKeyPress(event)">
                    <button id="sendBtn" onclick="sendMessage()">전송</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 탭 전환
        function showTab(tabId) {
            // 모든 탭 비활성화
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 선택된 탭 활성화
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        // 메시지 추가
        function addMessage(message, isUser) {
            const chatBox = document.getElementById('chatBox');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + (isUser ? 'user-message' : 'bot-message');
            messageDiv.textContent = message;
            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // 채팅 메시지 전송
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (!message) return;

            // 사용자 메시지 표시
            addMessage(message, true);
            input.value = '';

            // 전송 버튼 비활성화
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.textContent = '전송중...';

            try {
                const response = await fetch('/api/chat/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({message: message})
                });
                
                const data = await response.json();
                addMessage(data.response, false);
                
            } catch (error) {
                console.error('Error:', error);
                addMessage('죄송합니다. 오류가 발생했습니다.', false);
            } finally {
                // 전송 버튼 복원
                sendBtn.disabled = false;
                sendBtn.textContent = '전송';
            }
        }

        // 텍스트 업로드
        async function uploadText() {
            const title = document.getElementById('textTitle').value.trim();
            const content = document.getElementById('textContent').value.trim();
            
            if (!content) {
                showMessage('내용을 입력해주세요.', 'error');
                return;
            }

            const uploadBtn = event.target;
            uploadBtn.disabled = true;
            uploadBtn.textContent = '업로드 중...';

            try {
                const response = await fetch('/api/upload-text/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: title || '직접 입력 문서',
                        text: content
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showMessage(data.message, 'success');
                    document.getElementById('textTitle').value = '';
                    document.getElementById('textContent').value = '';
                    document.getElementById('docCount').textContent = data.document_count;
                } else {
                    showMessage(data.message, 'error');
                }
                
            } catch (error) {
                showMessage('업로드 중 오류가 발생했습니다.', 'error');
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = '텍스트 업로드';
            }
        }

        // 파일 업로드
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('파일을 선택해주세요.', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            const uploadBtn = event.target;
            uploadBtn.disabled = true;
            uploadBtn.textContent = '업로드 중...';

            try {
                const response = await fetch('/api/upload-file/', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showMessage(data.message, 'success');
                    fileInput.value = '';
                    document.getElementById('docCount').textContent = data.document_count;
                } else {
                    showMessage(data.message, 'error');
                }
                
            } catch (error) {
                showMessage('업로드 중 오류가 발생했습니다.', 'error');
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = '파일 업로드';
            }
        }

        // 메시지 표시
        function showMessage(message, type) {
            const messageDiv = document.getElementById('uploadMessage');
            messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.className = '';
            }, 5000);
        }

        // Enter 키 처리
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }
    </script>
</body>
</html>
```

이제 서버를 실행하고 테스트해보세요:

bash

```bash
python manage.py runserver
```

`http://127.0.0.1:8000`에서 확인할 수 있어요!